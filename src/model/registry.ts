// src/model/registry.ts

import type { Node, NodeId } from "./types.ts";

/**
 * ノードレジストリ
 *
 * ASTノードを一元管理するためのクラスです。レジストリという名前は、
 * ノードを「登録（register）」して、後で「検索（lookup）」できる
 * 仕組みであることを表しています。
 *
 * このクラスの役割は、シンプルですが重要です。
 *
 * 1. ノードの保管: 作成されたすべてのノードを Map で保持します
 * 2. IDの採番: 新しいノードに対して一意のIDを自動的に割り当てます
 * 3. ノードの検索: IDを指定してノードを取得できます
 *
 * なぜレジストリが必要なのでしょうか。ASTノードは、他のノードへの参照を
 * IDで持ちます（ref1、ref2プロパティ）。これにより、循環参照を避けつつ、
 * 複雑なグラフ構造を表現できます。レジストリは、このIDと実際のノードを
 * 結びつける橋渡しの役割を果たします。
 *
 * 例えば、「売上総利益 = 売上高 - 売上原価」という計算の場合、
 * 以下のような構造になります。
 *
 * ノードA (ID="1"): 売上高 (FF, value=577500)
 * ノードB (ID="2"): 売上原価 (FF, value=346500)
 * ノードC (ID="3"): 売上総利益 (TT, ref1="1", ref2="2", operator="SUB")
 *
 * ノードCは、ノードAとBのIDのみを保持し、実際のノードオブジェクトへの
 * 参照は持ちません。評価時には、レジストリを通じてIDから実際のノードを
 * 取得します。
 */
export class NodeRegistry {
  // ノードを格納する Map（IDをキー、Nodeオブジェクトを値とする）
  private nodes: Map<NodeId, Node> = new Map();

  // 次に割り当てるIDのカウンター
  private nextId: number = 1;

  /**
   * 新しいノードIDを生成します
   *
   * このメソッドは、新しいノードを作成する際に呼び出されます。
   * 内部カウンターをインクリメントすることで、常に一意のIDを
   * 生成することが保証されます。
   *
   * IDは文字列形式ですが、実際には連番の数値を文字列に変換したものです。
   * 文字列にする理由は、将来的にプレフィックスを付けたり（例: "node_1"）、
   * より複雑なID体系に移行したりする際の柔軟性を確保するためです。
   *
   * @returns 新しい一意のノードID
   */
  newId(): NodeId {
    const id = String(this.nextId);
    this.nextId += 1;
    return id;
  }

  /**
   * ノードをレジストリに追加します
   *
   * 新しく作成されたノードをレジストリに登録します。すでに同じIDの
   * ノードが存在する場合は上書きされますが、通常は newId() で生成された
   * 一意のIDを使用するため、重複は発生しません。
   *
   * このメソッドは、makeFF や makeTT 関数から呼び出されます。
   * これらの関数は、ノードを作成すると同時にレジストリに登録するため、
   * 作成されたすべてのノードが自動的に管理されます。
   *
   * @param node - 追加するノード
   */
  add(node: Node): void {
    this.nodes.set(node.id, node);
  }

  /**
   * ノードIDからノードを取得します
   *
   * 指定されたIDに対応するノードをレジストリから検索して返します。
   * これは、最も頻繁に使用されるメソッドです。
   *
   * トポロジカルソートや評価の過程で、ノードの ref1、ref2 プロパティから
   * 子ノードのIDを取得し、それをこのメソッドに渡すことで実際のノードを
   * 取得します。
   *
   * もし指定されたIDのノードが存在しない場合、エラーを投げます。
   * これは、プログラムのバグ（存在しないノードを参照している）を
   * 早期に発見するための安全機構です。
   *
   * @param id - 取得するノードのID
   * @returns 対応するノード
   * @throws 指定されたIDのノードが存在しない場合
   */
  get(id: NodeId): Node {
    const node = this.nodes.get(id);
    if (!node) {
      throw new Error(`ノードが見つかりません: ID=${id}`);
    }
    return node;
  }

  /**
   * レジストリ内のすべてのノードを取得します
   *
   * デバッグやログ出力の際に、レジストリの状態全体を確認するために
   * 使用します。返される配列の順序は、ノードが追加された順序とは
   * 限りません（Mapの実装に依存します）。
   *
   * このメソッドは、以下のような用途で使用されます。
   *
   * 1. デバッグ出力: すべてのノードの状態を一覧表示
   * 2. グラフ可視化: ASTの全体構造を図示
   * 3. 検証: ノードの総数や構造の正当性チェック
   *
   * @returns すべてのノードの配列
   */
  all(): Node[] {
    return Array.from(this.nodes.values());
  }

  /**
   * レジストリをクリアします
   *
   * すべてのノードを削除し、IDカウンターをリセットします。
   * 新しい計算を始める際に、前回の状態をクリーンアップするために
   * 使用できます。
   *
   * ただし、簡素版FAMでは、各計算ごとに新しいインスタンスを
   * 作成する想定なので、このメソッドの使用頻度は低いです。
   * より高度な使用シナリオ（例: 同じFAMインスタンスで複数の
   * 異なる計算を順次実行する）で役立ちます。
   */
  clear(): void {
    this.nodes.clear();
    this.nextId = 1;
  }

  /**
   * レジストリ内のノード数を返します
   *
   * デバッグやログ出力で、どれだけのノードが作成されたかを
   * 確認するために使用します。ノード数は、計算の複雑さの
   * 指標にもなります。
   *
   * @returns ノードの総数
   */
  size(): number {
    return this.nodes.size;
  }
}
